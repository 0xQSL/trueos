#!/sbin/openrc-run
# Copyright (c) 2016 - Kris Moore <kris@ixsystems.com>
# Copyright (c) 2009-2015 The OpenRC Authors.
# See the Authors file at the top-level directory of this distribution and
# https://github.com/OpenRC/openrc/blob/master/AUTHORS
#
# This file is part of OpenRC. It is subject to the license terms in
# the LICENSE file found in the top-level directory of this
# distribution and at https://github.com/OpenRC/openrc/blob/master/LICENSE
# This file may not be copied, modified, propagated, or distributed
# except according to the terms contained in the LICENSE file.
#
# This script was inspired by the equivalent rc.d network from NetBSD.
#
# 2016-12-11 - Kris Moore - Improved to support per-interface sub-services
#

netif=${RC_SVCNAME##*.}
if [ -n "$netif" -a "$netif" != "network" ]; then
        network_device="$netif"
fi

# Until we can determine why devd is throwing some bogus
# $cdev = '' variables
if [ "$network_device" = "." ] ; then
	exit 1
fi
name="network"
[ -n "$network_device" ] && name="$name ($network_device)"


description="Configures network interfaces."
__nl="
"
IFCONFIG_CMD="/sbin/ifconfig"

depend()
{
        provide net
        need localmount
        after bootmisc modules
	keyword -jail -prefix -vserver -stop
}

find_wireless()
{
	local iface=
	for iface in $(/sbin/sysctl -b net.wlan.devices 2>/dev/null); do
		echo "${iface##*/}"
	done
}

# wireless_up
# 	Create the wlan[] devices
wireless_up()
{
	local iface= i=

	iface=$(find_wireless)
	if [ -n "$iface" ]; then
		# Get next wlan0 device name
		wnum="0"
		while :
		do
			ifconfig wlan${wnum} 2>/dev/null
			if [ $? -ne 0 ] ; then
				break
			fi
			wnum=`expr $wnum + 1`
		done

		# Create the wireless devices
		for i in $iface; do
			einfo "Created wlan${wnum}"
			${IFCONFIG_CMD} wlan${wnum} create wlandev $iface
			wnum=`expr $wnum + 1`
		done
	fi
}

# Destroy wlan devices
wireless_down()
{
	wnum="0"
	while :
	do
		ifconfig wlan${wnum} >/dev/null 2>/dev/null
		if [ $? -ne 0 ] ; then
			break
		fi
		${IFCONFIG_CMD} wlan${wnum} destroy
		wnum=`expr $wnum + 1`
	done
}

# clone_up
#	Create cloneable interfaces.
#
clone_up()
{
	local _list ifn ifopt _iflist _n tmpargs
	_list=
	_iflist=$*

	# create_args_IF
	for ifn in ${cloned_interfaces}; do
		# Parse ifn:ifopt.
		OIFS=$IFS; IFS=:; set -- $ifn; ifn=$1; ifopt=$2; IFS=$OIFS
		case $_iflist in
		""|$ifn|$ifn\ *|*\ $ifn\ *|*\ $ifn)	;;
		*)	continue ;;
		esac
		case $ifn in
		epair[0-9]*)
			# epair(4) uses epair[0-9] for creation and
			# epair[0-9][ab] for configuration.
			#
			# Skip if ${ifn}a or ${ifn}b already exist.
			if ${IFCONFIG_CMD} ${ifn}a > /dev/null 2>&1; then
				continue
			elif ${IFCONFIG_CMD} ${ifn}b > /dev/null 2>&1; then
				continue
			fi
			${IFCONFIG_CMD} ${ifn} create \
			    `get_if_var ${ifn} create_args_IF`
			if [ $? -eq 0 ]; then
				_list="$_list ${ifn}a ${ifn}b"
			fi
		;;
		*)
			# Skip if ${ifn} already exists.
			if ${IFCONFIG_CMD} $ifn > /dev/null 2>&1; then
				continue
			fi
			${IFCONFIG_CMD} ${ifn} create \
			    `get_if_var ${ifn} create_args_IF`
			if [ $? -eq 0 ]; then
				_list="$_list $ifn"
			fi
		esac
	done
	if [ -n "${_list# }" ]; then
		# Start the bridge service
		einfo "Created clone interfaces: ${_list# }."
	fi
}

# clone_down
#	Destroy cloned interfaces. Destroyed interfaces are echoed to
#	standard output.
#
clone_down()
{
	local _list ifn _difn ifopt _iflist _sticky
	_list=
	_iflist=$*

	: ${cloned_interfaces_sticky:=NO}
	if yesno cloned_interfaces_sticky; then
		_sticky=1
	else
		_sticky=0
	fi
	for ifn in ${cloned_interfaces} ${gif_interfaces}; do
		# Parse ifn:ifopt.
		OIFS=$IFS; IFS=:; set -- $ifn; ifn=$1; ifopt=$2; IFS=$OIFS
		case $ifopt:$_sticky in
		sticky:*)	continue ;;	# :sticky => not destroy
		nosticky:*)	;;		# :nosticky => destroy
		*:1)		continue ;;	# global sticky knob == 1
		esac
		case $_iflist in
		""|$ifn|$ifn\ *|*\ $ifn\ *|*\ $ifn)	;;
		*)	continue ;;
		esac
		case $ifn in
		epair[0-9]*)
			# Note: epair(4) uses epair[0-9] for removal and
			# epair[0-9][ab] for configuration.
			#
			# Skip if both of ${ifn}a and ${ifn}b do not exist.
			if ${IFCONFIG_CMD} ${ifn}a > /dev/null 2>&1; then
				_difn=${ifn}a
			elif ${IFCONFIG_CMD} ${ifn}b > /dev/null 2>&1; then
				_difn=${ifn}b
			else
				continue
			fi
			${IFCONFIG_CMD} -n $_difn destroy
			if [ $? -eq 0 ]; then
				_list="$_list ${ifn}a ${ifn}b"
			fi
		;;
		*)
			# Skip if ifn does not exist.
			if ! ${IFCONFIG_CMD} $ifn > /dev/null 2>&1; then
				continue
			fi
			${IFCONFIG_CMD} -n ${ifn} destroy
			if [ $? -eq 0 ]; then
				_list="$_list $ifn"
			fi
		;;
		esac
	done
	if [ -n "${_list# }" ]; then
		einfo "Destroyed clone interfaces: ${_list# }."
	fi
}

uniqify()
{
	local result= i=
	for i; do
		case " $result " in
		*" $i "*);;
		*) result="$result $i";;
		esac
	done
	echo "${result# *}"
}

reverse()
{
	local result= i=
	for i; do
		result="$i $result"
	done
	echo "${result# *}"
}

sys_interfaces()
{
	ifconfig -l$1
}

tentative()
{
	local inet= address= rest=

	local inet= address= rest=
	LC_ALL=C ifconfig -a | while read inet address rest; do
 		case "${inet}" in
		inet6)
			case "${rest}" in
			*" "tentative*) return 2;;
			esac
			;;
		esac
	done
}


auto_interfaces()
{
	local ifs= c= f=

	for f in /etc/ifconfig.*; do
		[ -f "$f" ] && printf "%s" "${f##*.} "
	done
	for f in /etc/ip.*; do
		[ -f "$f" ] && printf "%s" "${f##*.} "
	done
	echo
}

interfaces()
{
	uniqify $(sys_interfaces "$@") $interfaces $(auto_interfaces)
}

dumpargs()
{
	local f="$1"

	shift
	case "$@" in
	'')		[ -f "$f" ] && cat "$f";;
	*"$__nl"*)	echo "$@";;
	*)
		(
		 	set -o noglob
			IFS=';'; set -- $@
			IFS="$__nl"; echo "$*"
		);;
	esac
}

intup=false
runip()
{
	local int="$1" err=
	shift

	# Ensure we have a valid broadcast address
	case "$@" in
	*" broadcast "*|*" brd "*) ;;
	*:*) ;; # Ignore IPv6
	*) set -- "$@" brd +;;
	esac

	err=$(LC_ALL=C ip address add "$@" dev "$int" 2>&1)
	if [ -z "$err" ]; then
		# ip does not bring up the interface when adding addresses
		if ! $intup; then
			ip link set "$int" up
			intup=true
		fi
		return 0
	fi
	if [ "$err" = "RTNETLINK answers: File exists" ]; then
		ip address del "$@" dev "$int" 2>/dev/null
	fi
	# Localise the error
	ip address add "$@" dev "$int"
}

routeflush()
{
	route -qn flush
}

runargs()
{
	dumpargs "$@" | while read -r args; do
		case "$args" in
		''|"#"*)	;;
		*)
				(
				 	eval vebegin "${args#*!}"
					eval "${args#*!}"
					veend $?
				);;
		esac
	done
}

start_interface()
{
	int="$1"
	local func= cf=
	intv=$(shell_var "$int")
	eval upcmd=\$ifup_$intv
	for func in ip ifconfig; do
		eval cmd=\$${func}_$intv
		if [ -n "$cmd" -o -f /etc/"$func.$int" ]; then
			cf=/etc/"$func.$int"
			break
		fi
	done

	# Up the interfaces
	ifconfig $int up

	# Skip ifconfig lines that have some 'magic' DHCP/WPA keywords
	echo "$cmd" | grep -q -e "AUTO" -e "WPA" -e "DHCP" -e "IPV6"
	if [ $? -eq 0 ] ; then return 0; fi

	ebegin "Starting network ($int)"

	[ -n "$cf" -o -n "$upcmd" -o \
		-f /etc/ifup."$int" -o -f "$cf" ] || return 0
	veinfo "$int"
	case "$func" in
	ip)	func=runip; intup=false;;
	esac
	eindent
	runargs /etc/ifup."$int" "$upcmd"
	r=0
	dumpargs "$cf" "$cmd" | while read -r args; do
		case "$args" in
		''|"#"*)	;;
		"!"*)
				(
				 	eval vebegin "${args#*!}"
					eval "${args#*!}"
					veend $?
				);;
		*)
				(
				 	set -o noglob
					eval set -- "$args"
					vebegin "$@"
					$func "$int" "$@"
					veend $?
				);;
		esac
	done
	eoutdent

	eend 0

	# Set the routes
	set_default_route
}

start()
{
	# Have we been started on a specific network device?
	if [ -n "$network_device" ] ; then
		start_interface $network_device
		return $?
	fi

	local cr=0 r= int= intv= cmd= args= upcmd=

	if [ -z "$domainname" -a -s /etc/defaultdomain ]; then
		domainname=$(cat /etc/defaultdomain)
	fi
	if [ -n "$domainname" ]; then
		ebegin "Setting NIS domainname: $domainname"
		domainname "$domainname"
		eend $?
	fi

	# Flush old routes
	routeflush

	ebegin "Starting network services"
	# Spawn the network sub-services
	for int in $(interfaces); do
		ln -fs /etc/init.d/network /etc/init.d/network.${int}
		/sbin/service network.${int} start
	done
	eend $cr


	# Wait for any inet6 tentative addresses
	r=5
	while [ $r -gt 0 ]; do
		tentative || break
		[ $r = 5 ] && vebegin "Waiting for tentative addresses"
		sleep 1
		: $(( r -= 1 ))
	done
	if [ $r != 5 ]; then
		[ $r != 0 ]
		veend $?
	fi

	# Bring up the wireless interfaces
	wireless_up

	# Bring up cloned interfaces
	clone_up

	# Set the routes
	set_default_route
}

set_default_route()
{
	if [ -n "$defaultroute" ]; then
		ebegin "Setting default route $defaultroute"
		route add default $defaultroute >/dev/null 2>/dev/null
		eend $?
	elif [ -n "$defaultiproute" ]; then
		ebegin "Setting default route $defaultiproute"
		ip route add default $defaultiproute
		eend $?
	elif [ -n "$defaultrouter" ]; then
		ebegin "Setting the default route $defaultrouter"
		route add default $defaultrouter >/dev/null 2>/dev/null
		eend $?
	fi

	if [ -n "$defaultroute6" ]; then
		ebegin "Setting default route $defaultroute6"
		routecmd="route -inet6 add"
		$routecmd default $defaultroute6 >/dev/null 2>/dev/null
		eend $?
	elif [ -n "$defaultiproute6" ]; then
		ebegin "Setting default route $defaultiproute6"
		ip -f inet6 route add default $defaultiproute6
		eend $?
	fi

	return 0
}

stop_interface()
{
	int="$1"
	case "$int" in
		lo|lo0) return 0 ;;
		*) ;;
	esac
	intv=$(shell_var "$int")
	eval downcmd=\$ifdown_$intv
	eval cmd=\$ip_$intv
	[ -z "$cmd" ] && eval cmd=\$ifconfig_$intv
	if [ -n "$cmd" -o -f /etc/ip."$int" -o \
		-f /etc/ifconfig."$int" -o \
		-n "$downcmd" -o -f /etc/ifdown."$int" ];
	then
		veinfo "$int"
		runargs /etc/ifdown."$int" "$downcmd"
		if [ -x /sbin/ip ] || [ -x /bin/ip ]; then
			# We need to do this, otherwise we may
			# fail to add things correctly on restart
			ip address flush dev "$int" 2>/dev/null
		fi
		ifconfig "$int" down 2>/dev/null
		ifconfig "$int" destroy 2>/dev/null
	fi
	return 0
}

stop()
{
	# Don't stop the network at shutdown.
 	# We don't use the noshutdown keyword so that we are started again
	# correctly if we go back to multiuser.
	yesno ${keep_network:-YES} && yesno $RC_GOINGDOWN && return 0

	# If we are stopping a sub-network device
	if [ -n "$network_device" ] ; then
		stop_interface "$network_device"
		return $?
	fi

	local int= intv= cmd= downcmd= r=
	ebegin "Stopping network"
	routeflush

	# Stop all the sub-network processes
	for int in $(reverse $(interfaces u)); do
		ln -fs /etc/init.d/network /etc/init.d/network.${int}
		/sbin/service network.${int} stop
	done

	# Bring down cloned interfaces
	clone_down

	# Bring down wireless
	wireless_down

	eend 0
}
